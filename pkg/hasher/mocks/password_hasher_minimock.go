// Code generated by http://github.com/gojuno/minimock (v3.3.14). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/andredubov/golibs/pkg/hasher.PasswordHasher -o password_hasher_minimock.go -n PasswordHasherMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// PasswordHasherMock implements hasher.PasswordHasher
type PasswordHasherMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcComparePasswords          func(hashedPassword string, plainPassword string) (err error)
	inspectFuncComparePasswords   func(hashedPassword string, plainPassword string)
	afterComparePasswordsCounter  uint64
	beforeComparePasswordsCounter uint64
	ComparePasswordsMock          mPasswordHasherMockComparePasswords

	funcHashAndSalt          func(plainPassword string) (s1 string, err error)
	inspectFuncHashAndSalt   func(plainPassword string)
	afterHashAndSaltCounter  uint64
	beforeHashAndSaltCounter uint64
	HashAndSaltMock          mPasswordHasherMockHashAndSalt
}

// NewPasswordHasherMock returns a mock for hasher.PasswordHasher
func NewPasswordHasherMock(t minimock.Tester) *PasswordHasherMock {
	m := &PasswordHasherMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ComparePasswordsMock = mPasswordHasherMockComparePasswords{mock: m}
	m.ComparePasswordsMock.callArgs = []*PasswordHasherMockComparePasswordsParams{}

	m.HashAndSaltMock = mPasswordHasherMockHashAndSalt{mock: m}
	m.HashAndSaltMock.callArgs = []*PasswordHasherMockHashAndSaltParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPasswordHasherMockComparePasswords struct {
	optional           bool
	mock               *PasswordHasherMock
	defaultExpectation *PasswordHasherMockComparePasswordsExpectation
	expectations       []*PasswordHasherMockComparePasswordsExpectation

	callArgs []*PasswordHasherMockComparePasswordsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// PasswordHasherMockComparePasswordsExpectation specifies expectation struct of the PasswordHasher.ComparePasswords
type PasswordHasherMockComparePasswordsExpectation struct {
	mock      *PasswordHasherMock
	params    *PasswordHasherMockComparePasswordsParams
	paramPtrs *PasswordHasherMockComparePasswordsParamPtrs
	results   *PasswordHasherMockComparePasswordsResults
	Counter   uint64
}

// PasswordHasherMockComparePasswordsParams contains parameters of the PasswordHasher.ComparePasswords
type PasswordHasherMockComparePasswordsParams struct {
	hashedPassword string
	plainPassword  string
}

// PasswordHasherMockComparePasswordsParamPtrs contains pointers to parameters of the PasswordHasher.ComparePasswords
type PasswordHasherMockComparePasswordsParamPtrs struct {
	hashedPassword *string
	plainPassword  *string
}

// PasswordHasherMockComparePasswordsResults contains results of the PasswordHasher.ComparePasswords
type PasswordHasherMockComparePasswordsResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmComparePasswords *mPasswordHasherMockComparePasswords) Optional() *mPasswordHasherMockComparePasswords {
	mmComparePasswords.optional = true
	return mmComparePasswords
}

// Expect sets up expected params for PasswordHasher.ComparePasswords
func (mmComparePasswords *mPasswordHasherMockComparePasswords) Expect(hashedPassword string, plainPassword string) *mPasswordHasherMockComparePasswords {
	if mmComparePasswords.mock.funcComparePasswords != nil {
		mmComparePasswords.mock.t.Fatalf("PasswordHasherMock.ComparePasswords mock is already set by Set")
	}

	if mmComparePasswords.defaultExpectation == nil {
		mmComparePasswords.defaultExpectation = &PasswordHasherMockComparePasswordsExpectation{}
	}

	if mmComparePasswords.defaultExpectation.paramPtrs != nil {
		mmComparePasswords.mock.t.Fatalf("PasswordHasherMock.ComparePasswords mock is already set by ExpectParams functions")
	}

	mmComparePasswords.defaultExpectation.params = &PasswordHasherMockComparePasswordsParams{hashedPassword, plainPassword}
	for _, e := range mmComparePasswords.expectations {
		if minimock.Equal(e.params, mmComparePasswords.defaultExpectation.params) {
			mmComparePasswords.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmComparePasswords.defaultExpectation.params)
		}
	}

	return mmComparePasswords
}

// ExpectHashedPasswordParam1 sets up expected param hashedPassword for PasswordHasher.ComparePasswords
func (mmComparePasswords *mPasswordHasherMockComparePasswords) ExpectHashedPasswordParam1(hashedPassword string) *mPasswordHasherMockComparePasswords {
	if mmComparePasswords.mock.funcComparePasswords != nil {
		mmComparePasswords.mock.t.Fatalf("PasswordHasherMock.ComparePasswords mock is already set by Set")
	}

	if mmComparePasswords.defaultExpectation == nil {
		mmComparePasswords.defaultExpectation = &PasswordHasherMockComparePasswordsExpectation{}
	}

	if mmComparePasswords.defaultExpectation.params != nil {
		mmComparePasswords.mock.t.Fatalf("PasswordHasherMock.ComparePasswords mock is already set by Expect")
	}

	if mmComparePasswords.defaultExpectation.paramPtrs == nil {
		mmComparePasswords.defaultExpectation.paramPtrs = &PasswordHasherMockComparePasswordsParamPtrs{}
	}
	mmComparePasswords.defaultExpectation.paramPtrs.hashedPassword = &hashedPassword

	return mmComparePasswords
}

// ExpectPlainPasswordParam2 sets up expected param plainPassword for PasswordHasher.ComparePasswords
func (mmComparePasswords *mPasswordHasherMockComparePasswords) ExpectPlainPasswordParam2(plainPassword string) *mPasswordHasherMockComparePasswords {
	if mmComparePasswords.mock.funcComparePasswords != nil {
		mmComparePasswords.mock.t.Fatalf("PasswordHasherMock.ComparePasswords mock is already set by Set")
	}

	if mmComparePasswords.defaultExpectation == nil {
		mmComparePasswords.defaultExpectation = &PasswordHasherMockComparePasswordsExpectation{}
	}

	if mmComparePasswords.defaultExpectation.params != nil {
		mmComparePasswords.mock.t.Fatalf("PasswordHasherMock.ComparePasswords mock is already set by Expect")
	}

	if mmComparePasswords.defaultExpectation.paramPtrs == nil {
		mmComparePasswords.defaultExpectation.paramPtrs = &PasswordHasherMockComparePasswordsParamPtrs{}
	}
	mmComparePasswords.defaultExpectation.paramPtrs.plainPassword = &plainPassword

	return mmComparePasswords
}

// Inspect accepts an inspector function that has same arguments as the PasswordHasher.ComparePasswords
func (mmComparePasswords *mPasswordHasherMockComparePasswords) Inspect(f func(hashedPassword string, plainPassword string)) *mPasswordHasherMockComparePasswords {
	if mmComparePasswords.mock.inspectFuncComparePasswords != nil {
		mmComparePasswords.mock.t.Fatalf("Inspect function is already set for PasswordHasherMock.ComparePasswords")
	}

	mmComparePasswords.mock.inspectFuncComparePasswords = f

	return mmComparePasswords
}

// Return sets up results that will be returned by PasswordHasher.ComparePasswords
func (mmComparePasswords *mPasswordHasherMockComparePasswords) Return(err error) *PasswordHasherMock {
	if mmComparePasswords.mock.funcComparePasswords != nil {
		mmComparePasswords.mock.t.Fatalf("PasswordHasherMock.ComparePasswords mock is already set by Set")
	}

	if mmComparePasswords.defaultExpectation == nil {
		mmComparePasswords.defaultExpectation = &PasswordHasherMockComparePasswordsExpectation{mock: mmComparePasswords.mock}
	}
	mmComparePasswords.defaultExpectation.results = &PasswordHasherMockComparePasswordsResults{err}
	return mmComparePasswords.mock
}

// Set uses given function f to mock the PasswordHasher.ComparePasswords method
func (mmComparePasswords *mPasswordHasherMockComparePasswords) Set(f func(hashedPassword string, plainPassword string) (err error)) *PasswordHasherMock {
	if mmComparePasswords.defaultExpectation != nil {
		mmComparePasswords.mock.t.Fatalf("Default expectation is already set for the PasswordHasher.ComparePasswords method")
	}

	if len(mmComparePasswords.expectations) > 0 {
		mmComparePasswords.mock.t.Fatalf("Some expectations are already set for the PasswordHasher.ComparePasswords method")
	}

	mmComparePasswords.mock.funcComparePasswords = f
	return mmComparePasswords.mock
}

// When sets expectation for the PasswordHasher.ComparePasswords which will trigger the result defined by the following
// Then helper
func (mmComparePasswords *mPasswordHasherMockComparePasswords) When(hashedPassword string, plainPassword string) *PasswordHasherMockComparePasswordsExpectation {
	if mmComparePasswords.mock.funcComparePasswords != nil {
		mmComparePasswords.mock.t.Fatalf("PasswordHasherMock.ComparePasswords mock is already set by Set")
	}

	expectation := &PasswordHasherMockComparePasswordsExpectation{
		mock:   mmComparePasswords.mock,
		params: &PasswordHasherMockComparePasswordsParams{hashedPassword, plainPassword},
	}
	mmComparePasswords.expectations = append(mmComparePasswords.expectations, expectation)
	return expectation
}

// Then sets up PasswordHasher.ComparePasswords return parameters for the expectation previously defined by the When method
func (e *PasswordHasherMockComparePasswordsExpectation) Then(err error) *PasswordHasherMock {
	e.results = &PasswordHasherMockComparePasswordsResults{err}
	return e.mock
}

// Times sets number of times PasswordHasher.ComparePasswords should be invoked
func (mmComparePasswords *mPasswordHasherMockComparePasswords) Times(n uint64) *mPasswordHasherMockComparePasswords {
	if n == 0 {
		mmComparePasswords.mock.t.Fatalf("Times of PasswordHasherMock.ComparePasswords mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmComparePasswords.expectedInvocations, n)
	return mmComparePasswords
}

func (mmComparePasswords *mPasswordHasherMockComparePasswords) invocationsDone() bool {
	if len(mmComparePasswords.expectations) == 0 && mmComparePasswords.defaultExpectation == nil && mmComparePasswords.mock.funcComparePasswords == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmComparePasswords.mock.afterComparePasswordsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmComparePasswords.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ComparePasswords implements hasher.PasswordHasher
func (mmComparePasswords *PasswordHasherMock) ComparePasswords(hashedPassword string, plainPassword string) (err error) {
	mm_atomic.AddUint64(&mmComparePasswords.beforeComparePasswordsCounter, 1)
	defer mm_atomic.AddUint64(&mmComparePasswords.afterComparePasswordsCounter, 1)

	if mmComparePasswords.inspectFuncComparePasswords != nil {
		mmComparePasswords.inspectFuncComparePasswords(hashedPassword, plainPassword)
	}

	mm_params := PasswordHasherMockComparePasswordsParams{hashedPassword, plainPassword}

	// Record call args
	mmComparePasswords.ComparePasswordsMock.mutex.Lock()
	mmComparePasswords.ComparePasswordsMock.callArgs = append(mmComparePasswords.ComparePasswordsMock.callArgs, &mm_params)
	mmComparePasswords.ComparePasswordsMock.mutex.Unlock()

	for _, e := range mmComparePasswords.ComparePasswordsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmComparePasswords.ComparePasswordsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmComparePasswords.ComparePasswordsMock.defaultExpectation.Counter, 1)
		mm_want := mmComparePasswords.ComparePasswordsMock.defaultExpectation.params
		mm_want_ptrs := mmComparePasswords.ComparePasswordsMock.defaultExpectation.paramPtrs

		mm_got := PasswordHasherMockComparePasswordsParams{hashedPassword, plainPassword}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.hashedPassword != nil && !minimock.Equal(*mm_want_ptrs.hashedPassword, mm_got.hashedPassword) {
				mmComparePasswords.t.Errorf("PasswordHasherMock.ComparePasswords got unexpected parameter hashedPassword, want: %#v, got: %#v%s\n", *mm_want_ptrs.hashedPassword, mm_got.hashedPassword, minimock.Diff(*mm_want_ptrs.hashedPassword, mm_got.hashedPassword))
			}

			if mm_want_ptrs.plainPassword != nil && !minimock.Equal(*mm_want_ptrs.plainPassword, mm_got.plainPassword) {
				mmComparePasswords.t.Errorf("PasswordHasherMock.ComparePasswords got unexpected parameter plainPassword, want: %#v, got: %#v%s\n", *mm_want_ptrs.plainPassword, mm_got.plainPassword, minimock.Diff(*mm_want_ptrs.plainPassword, mm_got.plainPassword))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmComparePasswords.t.Errorf("PasswordHasherMock.ComparePasswords got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmComparePasswords.ComparePasswordsMock.defaultExpectation.results
		if mm_results == nil {
			mmComparePasswords.t.Fatal("No results are set for the PasswordHasherMock.ComparePasswords")
		}
		return (*mm_results).err
	}
	if mmComparePasswords.funcComparePasswords != nil {
		return mmComparePasswords.funcComparePasswords(hashedPassword, plainPassword)
	}
	mmComparePasswords.t.Fatalf("Unexpected call to PasswordHasherMock.ComparePasswords. %v %v", hashedPassword, plainPassword)
	return
}

// ComparePasswordsAfterCounter returns a count of finished PasswordHasherMock.ComparePasswords invocations
func (mmComparePasswords *PasswordHasherMock) ComparePasswordsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmComparePasswords.afterComparePasswordsCounter)
}

// ComparePasswordsBeforeCounter returns a count of PasswordHasherMock.ComparePasswords invocations
func (mmComparePasswords *PasswordHasherMock) ComparePasswordsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmComparePasswords.beforeComparePasswordsCounter)
}

// Calls returns a list of arguments used in each call to PasswordHasherMock.ComparePasswords.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmComparePasswords *mPasswordHasherMockComparePasswords) Calls() []*PasswordHasherMockComparePasswordsParams {
	mmComparePasswords.mutex.RLock()

	argCopy := make([]*PasswordHasherMockComparePasswordsParams, len(mmComparePasswords.callArgs))
	copy(argCopy, mmComparePasswords.callArgs)

	mmComparePasswords.mutex.RUnlock()

	return argCopy
}

// MinimockComparePasswordsDone returns true if the count of the ComparePasswords invocations corresponds
// the number of defined expectations
func (m *PasswordHasherMock) MinimockComparePasswordsDone() bool {
	if m.ComparePasswordsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ComparePasswordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ComparePasswordsMock.invocationsDone()
}

// MinimockComparePasswordsInspect logs each unmet expectation
func (m *PasswordHasherMock) MinimockComparePasswordsInspect() {
	for _, e := range m.ComparePasswordsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PasswordHasherMock.ComparePasswords with params: %#v", *e.params)
		}
	}

	afterComparePasswordsCounter := mm_atomic.LoadUint64(&m.afterComparePasswordsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ComparePasswordsMock.defaultExpectation != nil && afterComparePasswordsCounter < 1 {
		if m.ComparePasswordsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PasswordHasherMock.ComparePasswords")
		} else {
			m.t.Errorf("Expected call to PasswordHasherMock.ComparePasswords with params: %#v", *m.ComparePasswordsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcComparePasswords != nil && afterComparePasswordsCounter < 1 {
		m.t.Error("Expected call to PasswordHasherMock.ComparePasswords")
	}

	if !m.ComparePasswordsMock.invocationsDone() && afterComparePasswordsCounter > 0 {
		m.t.Errorf("Expected %d calls to PasswordHasherMock.ComparePasswords but found %d calls",
			mm_atomic.LoadUint64(&m.ComparePasswordsMock.expectedInvocations), afterComparePasswordsCounter)
	}
}

type mPasswordHasherMockHashAndSalt struct {
	optional           bool
	mock               *PasswordHasherMock
	defaultExpectation *PasswordHasherMockHashAndSaltExpectation
	expectations       []*PasswordHasherMockHashAndSaltExpectation

	callArgs []*PasswordHasherMockHashAndSaltParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// PasswordHasherMockHashAndSaltExpectation specifies expectation struct of the PasswordHasher.HashAndSalt
type PasswordHasherMockHashAndSaltExpectation struct {
	mock      *PasswordHasherMock
	params    *PasswordHasherMockHashAndSaltParams
	paramPtrs *PasswordHasherMockHashAndSaltParamPtrs
	results   *PasswordHasherMockHashAndSaltResults
	Counter   uint64
}

// PasswordHasherMockHashAndSaltParams contains parameters of the PasswordHasher.HashAndSalt
type PasswordHasherMockHashAndSaltParams struct {
	plainPassword string
}

// PasswordHasherMockHashAndSaltParamPtrs contains pointers to parameters of the PasswordHasher.HashAndSalt
type PasswordHasherMockHashAndSaltParamPtrs struct {
	plainPassword *string
}

// PasswordHasherMockHashAndSaltResults contains results of the PasswordHasher.HashAndSalt
type PasswordHasherMockHashAndSaltResults struct {
	s1  string
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHashAndSalt *mPasswordHasherMockHashAndSalt) Optional() *mPasswordHasherMockHashAndSalt {
	mmHashAndSalt.optional = true
	return mmHashAndSalt
}

// Expect sets up expected params for PasswordHasher.HashAndSalt
func (mmHashAndSalt *mPasswordHasherMockHashAndSalt) Expect(plainPassword string) *mPasswordHasherMockHashAndSalt {
	if mmHashAndSalt.mock.funcHashAndSalt != nil {
		mmHashAndSalt.mock.t.Fatalf("PasswordHasherMock.HashAndSalt mock is already set by Set")
	}

	if mmHashAndSalt.defaultExpectation == nil {
		mmHashAndSalt.defaultExpectation = &PasswordHasherMockHashAndSaltExpectation{}
	}

	if mmHashAndSalt.defaultExpectation.paramPtrs != nil {
		mmHashAndSalt.mock.t.Fatalf("PasswordHasherMock.HashAndSalt mock is already set by ExpectParams functions")
	}

	mmHashAndSalt.defaultExpectation.params = &PasswordHasherMockHashAndSaltParams{plainPassword}
	for _, e := range mmHashAndSalt.expectations {
		if minimock.Equal(e.params, mmHashAndSalt.defaultExpectation.params) {
			mmHashAndSalt.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHashAndSalt.defaultExpectation.params)
		}
	}

	return mmHashAndSalt
}

// ExpectPlainPasswordParam1 sets up expected param plainPassword for PasswordHasher.HashAndSalt
func (mmHashAndSalt *mPasswordHasherMockHashAndSalt) ExpectPlainPasswordParam1(plainPassword string) *mPasswordHasherMockHashAndSalt {
	if mmHashAndSalt.mock.funcHashAndSalt != nil {
		mmHashAndSalt.mock.t.Fatalf("PasswordHasherMock.HashAndSalt mock is already set by Set")
	}

	if mmHashAndSalt.defaultExpectation == nil {
		mmHashAndSalt.defaultExpectation = &PasswordHasherMockHashAndSaltExpectation{}
	}

	if mmHashAndSalt.defaultExpectation.params != nil {
		mmHashAndSalt.mock.t.Fatalf("PasswordHasherMock.HashAndSalt mock is already set by Expect")
	}

	if mmHashAndSalt.defaultExpectation.paramPtrs == nil {
		mmHashAndSalt.defaultExpectation.paramPtrs = &PasswordHasherMockHashAndSaltParamPtrs{}
	}
	mmHashAndSalt.defaultExpectation.paramPtrs.plainPassword = &plainPassword

	return mmHashAndSalt
}

// Inspect accepts an inspector function that has same arguments as the PasswordHasher.HashAndSalt
func (mmHashAndSalt *mPasswordHasherMockHashAndSalt) Inspect(f func(plainPassword string)) *mPasswordHasherMockHashAndSalt {
	if mmHashAndSalt.mock.inspectFuncHashAndSalt != nil {
		mmHashAndSalt.mock.t.Fatalf("Inspect function is already set for PasswordHasherMock.HashAndSalt")
	}

	mmHashAndSalt.mock.inspectFuncHashAndSalt = f

	return mmHashAndSalt
}

// Return sets up results that will be returned by PasswordHasher.HashAndSalt
func (mmHashAndSalt *mPasswordHasherMockHashAndSalt) Return(s1 string, err error) *PasswordHasherMock {
	if mmHashAndSalt.mock.funcHashAndSalt != nil {
		mmHashAndSalt.mock.t.Fatalf("PasswordHasherMock.HashAndSalt mock is already set by Set")
	}

	if mmHashAndSalt.defaultExpectation == nil {
		mmHashAndSalt.defaultExpectation = &PasswordHasherMockHashAndSaltExpectation{mock: mmHashAndSalt.mock}
	}
	mmHashAndSalt.defaultExpectation.results = &PasswordHasherMockHashAndSaltResults{s1, err}
	return mmHashAndSalt.mock
}

// Set uses given function f to mock the PasswordHasher.HashAndSalt method
func (mmHashAndSalt *mPasswordHasherMockHashAndSalt) Set(f func(plainPassword string) (s1 string, err error)) *PasswordHasherMock {
	if mmHashAndSalt.defaultExpectation != nil {
		mmHashAndSalt.mock.t.Fatalf("Default expectation is already set for the PasswordHasher.HashAndSalt method")
	}

	if len(mmHashAndSalt.expectations) > 0 {
		mmHashAndSalt.mock.t.Fatalf("Some expectations are already set for the PasswordHasher.HashAndSalt method")
	}

	mmHashAndSalt.mock.funcHashAndSalt = f
	return mmHashAndSalt.mock
}

// When sets expectation for the PasswordHasher.HashAndSalt which will trigger the result defined by the following
// Then helper
func (mmHashAndSalt *mPasswordHasherMockHashAndSalt) When(plainPassword string) *PasswordHasherMockHashAndSaltExpectation {
	if mmHashAndSalt.mock.funcHashAndSalt != nil {
		mmHashAndSalt.mock.t.Fatalf("PasswordHasherMock.HashAndSalt mock is already set by Set")
	}

	expectation := &PasswordHasherMockHashAndSaltExpectation{
		mock:   mmHashAndSalt.mock,
		params: &PasswordHasherMockHashAndSaltParams{plainPassword},
	}
	mmHashAndSalt.expectations = append(mmHashAndSalt.expectations, expectation)
	return expectation
}

// Then sets up PasswordHasher.HashAndSalt return parameters for the expectation previously defined by the When method
func (e *PasswordHasherMockHashAndSaltExpectation) Then(s1 string, err error) *PasswordHasherMock {
	e.results = &PasswordHasherMockHashAndSaltResults{s1, err}
	return e.mock
}

// Times sets number of times PasswordHasher.HashAndSalt should be invoked
func (mmHashAndSalt *mPasswordHasherMockHashAndSalt) Times(n uint64) *mPasswordHasherMockHashAndSalt {
	if n == 0 {
		mmHashAndSalt.mock.t.Fatalf("Times of PasswordHasherMock.HashAndSalt mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHashAndSalt.expectedInvocations, n)
	return mmHashAndSalt
}

func (mmHashAndSalt *mPasswordHasherMockHashAndSalt) invocationsDone() bool {
	if len(mmHashAndSalt.expectations) == 0 && mmHashAndSalt.defaultExpectation == nil && mmHashAndSalt.mock.funcHashAndSalt == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHashAndSalt.mock.afterHashAndSaltCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHashAndSalt.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HashAndSalt implements hasher.PasswordHasher
func (mmHashAndSalt *PasswordHasherMock) HashAndSalt(plainPassword string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmHashAndSalt.beforeHashAndSaltCounter, 1)
	defer mm_atomic.AddUint64(&mmHashAndSalt.afterHashAndSaltCounter, 1)

	if mmHashAndSalt.inspectFuncHashAndSalt != nil {
		mmHashAndSalt.inspectFuncHashAndSalt(plainPassword)
	}

	mm_params := PasswordHasherMockHashAndSaltParams{plainPassword}

	// Record call args
	mmHashAndSalt.HashAndSaltMock.mutex.Lock()
	mmHashAndSalt.HashAndSaltMock.callArgs = append(mmHashAndSalt.HashAndSaltMock.callArgs, &mm_params)
	mmHashAndSalt.HashAndSaltMock.mutex.Unlock()

	for _, e := range mmHashAndSalt.HashAndSaltMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmHashAndSalt.HashAndSaltMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHashAndSalt.HashAndSaltMock.defaultExpectation.Counter, 1)
		mm_want := mmHashAndSalt.HashAndSaltMock.defaultExpectation.params
		mm_want_ptrs := mmHashAndSalt.HashAndSaltMock.defaultExpectation.paramPtrs

		mm_got := PasswordHasherMockHashAndSaltParams{plainPassword}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.plainPassword != nil && !minimock.Equal(*mm_want_ptrs.plainPassword, mm_got.plainPassword) {
				mmHashAndSalt.t.Errorf("PasswordHasherMock.HashAndSalt got unexpected parameter plainPassword, want: %#v, got: %#v%s\n", *mm_want_ptrs.plainPassword, mm_got.plainPassword, minimock.Diff(*mm_want_ptrs.plainPassword, mm_got.plainPassword))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHashAndSalt.t.Errorf("PasswordHasherMock.HashAndSalt got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHashAndSalt.HashAndSaltMock.defaultExpectation.results
		if mm_results == nil {
			mmHashAndSalt.t.Fatal("No results are set for the PasswordHasherMock.HashAndSalt")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmHashAndSalt.funcHashAndSalt != nil {
		return mmHashAndSalt.funcHashAndSalt(plainPassword)
	}
	mmHashAndSalt.t.Fatalf("Unexpected call to PasswordHasherMock.HashAndSalt. %v", plainPassword)
	return
}

// HashAndSaltAfterCounter returns a count of finished PasswordHasherMock.HashAndSalt invocations
func (mmHashAndSalt *PasswordHasherMock) HashAndSaltAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHashAndSalt.afterHashAndSaltCounter)
}

// HashAndSaltBeforeCounter returns a count of PasswordHasherMock.HashAndSalt invocations
func (mmHashAndSalt *PasswordHasherMock) HashAndSaltBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHashAndSalt.beforeHashAndSaltCounter)
}

// Calls returns a list of arguments used in each call to PasswordHasherMock.HashAndSalt.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHashAndSalt *mPasswordHasherMockHashAndSalt) Calls() []*PasswordHasherMockHashAndSaltParams {
	mmHashAndSalt.mutex.RLock()

	argCopy := make([]*PasswordHasherMockHashAndSaltParams, len(mmHashAndSalt.callArgs))
	copy(argCopy, mmHashAndSalt.callArgs)

	mmHashAndSalt.mutex.RUnlock()

	return argCopy
}

// MinimockHashAndSaltDone returns true if the count of the HashAndSalt invocations corresponds
// the number of defined expectations
func (m *PasswordHasherMock) MinimockHashAndSaltDone() bool {
	if m.HashAndSaltMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HashAndSaltMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HashAndSaltMock.invocationsDone()
}

// MinimockHashAndSaltInspect logs each unmet expectation
func (m *PasswordHasherMock) MinimockHashAndSaltInspect() {
	for _, e := range m.HashAndSaltMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PasswordHasherMock.HashAndSalt with params: %#v", *e.params)
		}
	}

	afterHashAndSaltCounter := mm_atomic.LoadUint64(&m.afterHashAndSaltCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HashAndSaltMock.defaultExpectation != nil && afterHashAndSaltCounter < 1 {
		if m.HashAndSaltMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PasswordHasherMock.HashAndSalt")
		} else {
			m.t.Errorf("Expected call to PasswordHasherMock.HashAndSalt with params: %#v", *m.HashAndSaltMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHashAndSalt != nil && afterHashAndSaltCounter < 1 {
		m.t.Error("Expected call to PasswordHasherMock.HashAndSalt")
	}

	if !m.HashAndSaltMock.invocationsDone() && afterHashAndSaltCounter > 0 {
		m.t.Errorf("Expected %d calls to PasswordHasherMock.HashAndSalt but found %d calls",
			mm_atomic.LoadUint64(&m.HashAndSaltMock.expectedInvocations), afterHashAndSaltCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PasswordHasherMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockComparePasswordsInspect()

			m.MinimockHashAndSaltInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PasswordHasherMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PasswordHasherMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockComparePasswordsDone() &&
		m.MinimockHashAndSaltDone()
}
